28th of March, 2025

The goal here is to make a text based game, but we're going to use Interactive Fiction as our base. First, we want to navigate rooms like normal, but we want the description to stay on the page. Let's start be creating locations, the ability to move between them, and descriptions for each room which will stay on the page.

Just realized we need to think through how direction works. First, I really want this game to work with controller. IF games use a cardinal direciton system. It's very tempting to steal this, but I liked the idea of having more flexibility in my system. For example, what if we wanted two parallel hallways leading north from a room? Basically two NORTH exits? In this was a keyboard IF game we could just demand a specific prompt from the player. But if this needs to work with controller then we can't type specific text. Maybe we just add sub-connections on the same cardinal direction, and we ask the player which one they meant if there's more than one?

Maybe it's better to not overthink this. Let's hard to commit to the 4 cardinal directions and the intercardinal directions, as well as up and down. It's simple. The 8 cardinal directions already work on any directional input device, and I'm sure we can figure something out for up and down. So doing this, we need to specify the type of direction for any given connection in a location.

This is a smart idea because it will standardize movement throughout the world. And gives us a way to start planning how to implement controls for both controller and keyboard/mouse.

Let's steal the compass idea from that other game. With that, it was very easy to determine where we could go from any location. We should also steal the map. That was extremely useful, and helped make the world feel more real. There may not be enough space on screen for regular text and the map. We'll have to reflect on how we want this implemented.


31st of March, 2025

Did some more thinking about actions. If we want this to be playable with a controller it needs to be easy to select between a variety of abilities and targets for those abilities. Like a modern 3D adventure game, I'm thinking we can streamline this by only having 4-5 actions, kinda like buttons on a controller. They'll probably be:

examine
talk
attack
interact

Maybe some others depending on game mechanics we can think of. Also, I think the types of targets could be simplified. Basically just:

NPCs
enemies
objects
exits

I was thinking the top half of the screen could be devoted to just the room description. Then the bottom have could be divided in columns each containing a list of those targets I mentioned above. A hotkey/button could be assigns to each column, and using a direction input chooses from those targets. After selecting a target, a popup menu of possible actions could appear. I suppose if we did it that way, we could have any number of actions for a given target.

Exits could be a separate pop-up menu instead of its own column. Perhaps we always show the compass, and descriptions of the exits. But when you hit a button, a travel hotkey of some kind, the compass becomes highlighted and now you can choose a direction on the compass to travel.

I suppose we could also implement mouse support so mouse users can just click on these things.

In traditional IF games you can just type what you want to do, and I think the parsers are smart enough to figure out the target and action in one swoop. And in those games I suppose the commands can be more complex than a simple "target" -> "action". So for this game I guess the challenge is how to make it intiutive to interact with targets in the description.

Will the game be too easy if all interactable game objects are just listed for the player under "target" columns? Maybe, but I don't think I can know for sure until I try.

Also just realized we could easily put a description for each item in unused screen space when we highlight it. Or maybe we want examining an object to be a deliberate action? Something to explore.

Also making a note that, although I've already stated I want this to be playable with controller, I'd also like it to be playable on arcade stick. Partly because I think that'd be cool, but also it forces us to keep the control scheme so simple that it could work with any modern controller. It could maybe even work on a retro-gaming emulation device which usually only has a d-pad and 4 face buttons.

After doing some more reflecting, I think it's too hard to make up a plan for all of this in my head. Let's try adding some basic items to the rooms that we can examine. We'll play around with the controls for moving between rooms as well. I think if we can get moving between rooms and examining items to feel natural, then we're on the right path.

Actually, no, we have to think through how we want interacting with travel options and objects to work. Right now I just have it rigged to read arrow key inputs and change room on space press. But we're going to use those same arrow keys for selecting objects. Ah, perhaps we'll start with using our hotkey idea from earlier, where you choose a travel or targets menu first. I'm torn on how we should layout the travel options. I really like the idea of maintaining the compass layout but I can tell I'm unsure how that will work with selecting the options. So maybe we'll just use a list layout for now.

Maybe if instead of using a hotkey system, we simply list "travel" as option in addition to the targets in the room? Actually, we could have both. Let's try just listing travel as an option. Also let's just call it "move" from here on.


6th of April, 2025

Just looked back over notes. I forgot we decided to list "move" as an option by default just like other items in the room. Or I should say "targets" in the room. Things that can be interacted with. I think I only said this because I'm not 100% sure what I want yet. And just making it a regular option gives us a way to keep moving forward to code. On reflection I don't think this will work well because movement is something separate from interacting with targets. It's kind of its own game mechanic.

Let's start thinking of the game in terms of different menus. And right now I can think of 2. There's the regular targets menu, when you can choose targets within a location like objects, characters, or enemies. And we'll have the movement menu where you can choose directions to move within a location. We could assign hotkeys/buttons that bring up these different menus. Also for the movement menu, I think we should layout the options like a compass, we'll put some sort of null option for directions that can't be selected. This gives us an elegant way to select everything, including up/down.

Let's try adding that menu first.

It occured to me I've lost site of the mini-map. I think we need to keep that otherwise it's too easy to lose track of where you are physically in the story. But for now, let's have the move menu in the bottom left where we used to have the compass. It basically is the compass, just a slightly different thing. So it will always be visible, you just can't interact with it until you select that menu with the hotkey.

I've got a movement menu now. I decided to only make it visible when in move mode. I'm not convinced I like the layout yet but we'll go with it for now. Next we should add targets within the room that can be examined.

I've decided I'd like to list targets, and then list options for targets after they've been selected. This is instead of doing something where you choose the action you want to perform first, then the target. Are we sacrificing gameplay creativity here? For example what if we wanted the player to try and "talk" to an inanimate object? I suppose we are, but ultimately any decision we make probably has a tradeoff. In this case I think selecting target then action is more intuitive and is worth it. 

I've been very focused on a game that will work with controllers. But perhaps in the future we can make a text game that relies on keyboard excusively. This would open up all kinds of control and creativity options. Or maybe we'll change our minds about how this game works partway through. It shouldn't be too hard a change since this whole system will rely on action -> target interactions.

Anyway, let's try adding items to the rooms which can be selected from the targets menu. We'll consider this to be "examining" the item. When this happens we'll display the examination description of the item. The user will have to press "back" to get back to the targets menu. I think we'll also display action options for the target here as well, but I'm not sure what those are yet, so we'll stick to just displaying the examination description.

We should probably change the name of "target" to "interactable" or something similar. Target isn't quite the right name.

Got a simple system going. But it's clear we'll need to think through targets more completely before going too far. These are how we'll interact with the entire game world. We haven't even thought about inventory yet. How does something like picking up a key and using it to unlock a chest in another room work? Should targets being something that can exist in a location as well as the player inventory? Do we have a traditional inventory?

Like so many things, let's just assume we have a traditional game inventory so we can keep moving forward. And we'll assume it's magical in the sense that it's not an explicit backpack or pouch on the player character. It just magically exists like in most games.

Actually, I think we can simple create the location "inventory" and leave it at that. We don't have to create this location in the game world. Targets already have the ability to reference it, and we can draw targets in the "inventory" location when displaying player inventory just like when viewing a location. As for keeping tack of what can/can't be in the inventory, I'm sure we can ignore that for now.

Or maybe we shouldn't. Perhaps now it's time to figure out talking to characters and picking up items. Those are key game concepts we'll use. Perhaps a target/interactable has the ability to enter the inventory simply based on whether or not it has the "take" action. We'll also have to think through actions for interactables.

I'm also still on the fence about what to call targets. It feels wrong but I also don't like "interactable". It's too long.

I'm tempted to steal the conversation format that Morrowind used. We just display whatever the character just said, and list conversation topics that can be selected. Actually, this is exactly how displaying location descriptions and targets works atm.

We may not want to hardcode every single "mode" the game can be in. I think I don't want to display the location description while having a conversation. We could probably just use the same updateable system we've used in other games here. Honestly we need to implement a system like that just so we have flexibility later on. Like if we want a section that simply narrates a bunch of text.

Perhaps we should start by reworking our current logic to use updateable nodes. Then we can write a conversation node.


7th of April, 2025

Tried reflecting more on the interface. I want the information the player interacts with the most to be center screen. So I'm considering placing descriptions for targets within a location in center/top of the screen, move the location description to left side, and then list the actual interaction options menu below. Since targets could vary for the same location depending on game state, this gives us a way to vary the descriptions displayed front and center. And I think it feels clearer to the player what's happening in the underlying game mechanics without breaking immersion (hopefully). Additionally I bet we could list movement options along with 
targets, which I'm hoping will feel a little more organic. I mean, in a regular 3D action game, when you enter a room, you look around and decide what you want to do. It could be push a button, or read a piece of paper on a desk, talk to an NPC, or leave through a door you see. All these things are in the same sort of option space mentally, so I think it makes sense to list them in the same ui place.

All of this has to be tested though.

I'm a little worried about maintaining the compass layout we have right now. I do think keeping movement direction options consistent is important for good gameplay feel. So while most interactable options in a location could be listed in a regular list, I'm not sure how to incorporate movement options. We shouldn't remove the idea of just listing them in a regular list though. It's very possible that it'll feel totally natural, especially if we kept the same order all the time (North first, then West, East, and so on).

Actually I've sort of convinced myself, let's try listing movement options in a regular list next.

But there's something about target options that's bothering me. At the moment I'm considering displaying a description of everything, then listing the options. Here's an example:

---------------------------------
A small wooden table sits in the corner. And on top of it rests a single candle in a brass holder. Its flame is gentle. The glint of a key can be seen next to the candle. To the North you see a door. And to the West the wooden planks have fallen away revealing a stone wall with a hole small enough to crawl through.

- table
- candle
- key
- door (North)
- hole (West)
---------------------------------

What I don't like about this, is we've sort of listed everything twice. For example if the player wanted to interact with the key they have to read the sentence describing the key first, then select the option at the bottom of the screen. I almost feel like they should interact with that sentence itself. If we were comitted to mouse controls we could have the player click on the word itself (not a bad idea actually, keep that in mind for the future). Maybe it makes more sense to insist on each interactable being a separate sentence? Something like this:

---------------------------------
- A small wooden table sits in the corner.
- And on top of it rests a single candle in a brass holder. Its flame is gentle.
- The glint of a key can be seen next to the candle.
- To the North you see a door.
- To the West the wooden planks have fallen away revealing a stone wall with a hole small enough to crawl through.
---------------------------------

Actually I hate that. I want to keep blocks of descriptive text. I think it keeps you in the story better, instead of looking like obvious game options. Let's go with the first option. Looking over that I wonder if we actually need the location description on the side. I bet we could just put it right there with the descriptions of targets. Maybe all we need to separate the description of the room and the targets is a new line? Should movement options be listed before or after targets? Does it matter?


8th of April, 2025

Did some more reflecting. If we're willing to list movement options along with target options, and list the options separately from description, I think we can just keep coding. We make functions to get a string for each of those descriptions, and we'll just write all of them in the same draw function. It'll be easy to split this up later and draw things in separate locations on the screen if we want.

Something to consider though, is how movement options are listed. In our example above we listed the directions as the object to interact with (door, hole), not the direction. But we only store the direction and name of location in a connection. We need to add this data somewhere. Though for a brief re-write let's just use the connection direction.


3rd of May, 2025

Second-guessing myself on movement again. Now I think there shouldn't even be directions as a hard coded concept. I think it's better to allow total freedom for connections to other cells. I now believe the whole world should just be a graph, where each area is a node with any number of connections between other nodes. I don't think there should be strict logic here. This means we won't (more like can't) worry about clarifying the direction as a concept in the option listing. But this does mean we'll have to be good with our descriptions of connections to other areas. Also, this means we'll have to use old-fashioned manual planning and work to create the maps.

To restate and be clear, a minimap I think is crucial to this working. In-fact it's basically the mechanic that inspired revisiting this game concept. With just the visual of a map, the entire text genre is easy to get immersed in.

Just had an idea for creating the map. We could add a reference to an area visual, a sprite, in the node itself. Then when rendering the map, we could use data from that node itself. I'm not sure how the position data should be stored though. It will probably have to be relative to some point.

Let's revamp our vocabulary here. Instead of area, let's call them cells. We're stealing that word from TES games. A cell is the most specific location unit the game has. The player and all game entities will always be in some cell. Now, we'll call a collection of cells an area. For example: a building full of rooms is an area, and each room in that building is a cell. I think we'll consider something like a city an area as well because we'd use cells to implement roads, streets, small parks, and other similar locations within a city.

Actually we might need to clarify this a bit more. We're basically figuring out when we stop showing connections between cells. For example, if the area map is showing all the cells of streets and parks in a city, we won't show the cells of the interior buildings. We'd probably show something in their place. But then, if we're outside the city, on the roads that travel up to it, we won't show the cells of the city, we'll show some generic icon probably. I understand the behavior I want, I'm just not sure how this should be implemented. 

Ah, I just had an idea. Ultimately this only matters for drawing the map. So all that matters is whether or not we continue drawing cell shapes, or some other icon. Perhaps we could assign an area name to each cell, as well as an area icon. Then, when drawing the area map, we'll use some sort of graph traversal to visit and draw cell icons for each cell, but if that cell is not in the same area as the one the player is in, we instead draw the area icon of that cell. That icon could still have position data and such.

I think that idea works, and easily encapulates everything we're trying to accomplish without requiring a more complex implementation.


4th of May, 2025

Went back over my old notes. Originally I wanted to insist on standardized directions to keep things simple for controllers. But if we're just listing connections between cells I don't think it'll be an issue for controller navigation. So, let's abandon the need for a specified direction in cell connections.

Also had an idea for how to handle drawing area maps. We could first draw the entire area, making sure to use outlines to clearly separate different cells. Then to create the cell images we just copy this map over and over, erasing everything except for 1 cell for each cell. That way we can ensure they all line up relative to each other properly.

Something that might be worth considering is random generation. I'm very tempted to not touch this because A: I'm very inexperienced in it and B: I heavily doubt the game will feel compelling without hand crafted environments. But I could be wrong. Let's keep it in mind, especially since it'd be much easier to create lots of cells with some sort of generation system.

Actually what we should do is make sure our underlying data structure for environments works well for hand-crafted or automatically generated. Perhaps the final project could be a mix.

Realized I'm letting my mind race again about movement. I still agree with my previous decision to list cell connections along with interaction options. But each connection needs text for the listing as well as further elaboration text. Do we display the elaboration text when the user highlights the listing? Actually this relates to how we want interactions in general to work. I want to force players to press buttons to see further descriptions of things because I think it'll feel more immersive. But I could be completely wrong.

Actually after opening up the code we have again, I definitely don't want descriptions to just appear when hoving over options. I think it looks crappy. They should only appear after some sort of interaction. Also I definitely want the most recent piece of text the player needs to read to be center of the screen. Maybe what's really throwing me off is cell descriptions. I want the description of a cell to be visible to the player so they always have a reference of what it looks like. But I think I also want that to be presented to the player in a special way when they enter a cell. Probably especially if it's the first time they've ever entered that area.

It's very possible I'm overcomplicating all of this, and just creating an IF game that works with controller, and displays a mini-map would serve all my needs.

Perhaps we should re-approach this as only displaying single chunks of text center screen, one at a time. Then we let the sides of the screen be the options. Maybe we should try just re-arranging the code we have now to do that. Though how will that work with options that require sub menus?

There's more than enough screen space to display a list of options, and an entire column for sub-options, while still keeping the main chunk of text center-screen. We could also list sub-options below the main chunk of text. I'm not sure how I want the ability to de-select options to work though. Also I don't think I ever solved my cell-description confusion.

Let's do our old trick of committing to a specific strategy, regardless of how good we think it is, just to keep code going. Let's make the area description display in a corner of the screen at all times. We'll just display "You enter <cell name>." in the main text area on entering a space. We'll display a list of options on the left side of the screen. Selecting one will immediately display elaborated text center-screen. I guess for now we're committing to the idea of "examine" on select. For now let's try listing sub-options below the main text after selection. Though I think our only functional option is "travel" for cell-connections at the moment. The only thing I'm not sure about is how focus should work with sub-options. What I mean there is, if you select an option with sub-options, is the focus now in the sub-option menu? Or should it stay in the options menu moving focus to the sub-menu requires a specific button press? I think I like that second option better. Like a hotkey with a "further actions" label or something.

Ok I like it. To summarize:
cell descriptions in top-right corner
options vertically left side
result of option select center screen (or maybe top center, whatever looks best)
special key to move focus from options menu to sub-options menu for any given option

I moved things around to where I described them. I haven't finished implementing the new focus logic, but I don't need to yet. I quickly learned I absolutely hate the look of the location description being on the top right. I immediately tune it out of my vision and mind. I'm starting to believe I'm wrong for insisting the cell description always be on screen. Let's try not drawing it for a while and see where that gets us.

So this means the next step is to rework what happens when entering a room, and selecting an option. We don't currently have logic for setting new text.

We'll have to rework how options are stored. Right now we make an array of strings from the room connections and the options within the cell. I think we should do something similar, but instead create option objects with a on_select callback of some kind, and other data. We can keep a "text to display" variable as the text which appears center screen. And these on_select callbacks will change that value.

For sub-options, I wonder if the system should always have a sub-options array ready to display, and it just gets populated by the on_select callbacks. Or maybe this should be something more flexible in-case we want something weirder when an option is selected? Like maybe the main text should actually be like it's own updateable that can be given focus. Actually I kind of like that because it will be very flexible.

Summary for next goal:
create main text area which is actually its own udpateable object
rework options so they have a on_select callback that changes main text area
rework cell connection options so they work with this new system


6th of May, 2025

As I implement my new system, I kind of hate all my old code. I think this is mostly due to not knowing how we want things to work. For example targets have multiple ways of getting their description.

Also, Just from feel alone, I don't think the general idea for options here is going to work. It feels super lame to just select from a list of things. I think the game will just feel like menu navigation forever.

We should keep pushing forward with our above plan, but be very aware of this issue.


7th of May, 2025 (am hours)

Just throwing out an idea I had during the day. What if we change the layout of options based on the cell the player is in? Like if they're in a city staring down streets, does it make sense to have the names of people lines up on the side of the screen, like people walking down sides of the street? With names of building the player can enter behind the people? Or in a dungeon could object names be distributed around rooms as they actually would if standing there in that room?

Also, it may be possible to still use some form of graphics for this, but it still depends heavily on text. What if we had a top down display with simple icons for navigating a space? We could even make the space heavily tile based so your character is only ever in a specific tile. Or perhaps we could just use actual boxes with text inside of them. Like a small box with "you" in the center for the player.

Though would both these ideas we still have a main text area the player will read most of the game responses from. And I have to say using any sort of complex interface like I just described makes me nervoux because I think it'll feel like the true "game" is the graphical interface, and not the text. It really needs to feel like you're interacting with the giant text block itself.

What if we created better tools for highlighting and interacting with a block of text, and simply used the center text as the list of options? Did I already have this idea and dismiss it? Let's re-examine. What if we saw this text on entering a cell:

---
The dark green carpet smushes as you enter the library.

The two story walls are covered in shelves of books. Rows and columns of even more shelves fill the floor space. Dusty air fills your nose and sunlight from the tall arched windows warms your face. At the wooden desk near the entrance you came in from, the librarian looks up and adjusts her plain black-rimmed glasses at you. She puffs her old white bangs aside with a brief exhale and tuggs at her pink sweater before turning back down to her work.
---

Damn, writing is harder than I thought it was.
Anyway. Now imagine that we could highlight words in this text. We could just use the control stick for changing row and column of text. Then once a word is highlighted, activating it reveals action options. Or perhaps we go back to our old system of choosing action then target? For some reason that feels better for this.

I do think we need to be able to further examine things listed there without removing the main block of text. For example, I want to be able to examine the "windows" and see a unique description of them without losing that original block of text. That way it's easy to examine elements in an area, or a description, without having to invoke some command that displays that original block of text again.

I like this idea. But need to review it again when I'm more fresh.


7th of May, 2025 (evening)

After some time away, I still like this idea. However I think this will take more time to implement than my other ideas. That's because each word in the text must be interactable. At least I'm pretty sure of this. I don't think there's anyway around the need for the code to know the location of each individual word. If we allow mouse clicking on words, we certainly need each word to have a "hurtbox" of sorts. If we use the controller to iterate over rows and words of text, we'll still need to know where the word is to highlight, underline, or somehow identify the word we've selected.

The only thing I can think of that would still let us use the regular draw text function is to just not do anything to identify the word we're selecting and simply display it somewhere on the screen, and hope the user can feel out where their invisible cursor is within the text. 

But that's dumb. We should figure out a system that let's us change the color/font/style of the selected word. Which I think also involves a system where we can identify what text is hovered by the mouse.

Firstly, to be quite frank, I'm pretty sure we could just draw everything character individually for this. I think we can get away with that here because There will be no other graphics in this game. A super rough estimate is 1000 characters per page, which I'm sure is fine for drawing here.

Actually... is it? Why don't we check this first.

Ok, maybe we do want to optimize. Drawing 3000 individual characters on my machine yields a framerate of 500-600. This is dramatically lower than just drawing the same block of text at once. A shame our old text code never accounted for this. Let's start planning.

There aren't any functions that will handle line breaks for us here, so we'll have to do that ourselves. This means we'll be drawing, at minimum, each row of text. So I bet we could design a system that only does complicated stuff with the row currently highlighted, and leaves all other alone.

Though, since we're opening the gates to doing complicated text stuff, I really like the idea of introducing cool typing effects. Perhaps we want to create a variation of our other system where we keep an array of characters, but split up and re-connect individually drawn characters into entire strings once characters no longer need to be drawn separately for any reason. 

In this case, I think it means we need to implement the same drawable system we used in our other code. A collections of drawables is a linked list of structs, each containing a string of text to draw, and style information for how to draw that text. These can be split apart and reconnected as needed. So in this system, each row will be at minimum 1 drawable (the entire row of text).

Now... our old system included character index ranges for drawables. And there was an array of the original characters. Each entry in that array included the location and style of each character. In that system we used the first character index in a drawable as its anchor point. For example, look at the following data:

// original text
The quick brown fox jumps over the lazy dog.

{
    text: " over the lazy dog.",
    char_index_start: 26,
    char_index_end: 43,
    style: {} // some object of style info
}

So in that case, we'd draw this drawable at whatever position is logged for character 26 in the original character array.

We could easily create functions that split these drawables. We've already done it actually. Something I'm unsure about though is when is best to reconnect them. For this situation, it might actually be best to just rebuild everything at once. Or more accurately, create a new drawable containing the text of the entire row once it's been drawn. Let's commit to that strategy for now.

Actually if we use this drawable strategy, I think we can put off creating typing effects. Like our old system, we could create an animator object which contains information about what has and hasn't been typed. And this object could apply splits, cuts, and style changes to the drawables. If we create the drawable system, with functions for making edits, we can worry about typing animation logic later. Let's do that.

We need to plan out how word selection will work though... If we have the array of characters, each with position and size data, then we're already mostly there. But I like the idea of not iterating over the entire array of characters each frame. Could we just do each word? Once we've already parsed the text and created the character array, we could iterate over that again and create a word array using the same position data. That way we could have a function like this:

get_word_at_xy(x, y)

which works by just iterating over the word array and returning the first entry with position data that fits the given xy.

I like the idea of a separate array for identifying words, but I'm concerned that limiting it to only words won't be a good idea in the long run. What if we want the subject the player interacts with to be multiple words? I think a likely scenario is a passage of text where the same word represents two important but very different targets. For example: a south door and a north door. If we want to go through the north door, I think the system should be able to highlight "north door" if we try to select just "door". Furthermore, we don't need position data for every word in a piece of text. We can skip over things like pronouns, indefinite articles, and other fancy such grammar jargon. So I think the system should be designed to only single out words if we tell it to.

Wait, maybe we do need to allow for highlighting every word. Controllers will need to be able to move from word to word. I suppose we could highlight only the words/groups players can interact with. But I'm concerned this will cheapen the game? Crap, I'm not actually sure what's best here, which means we'll need to try different things.

Well, luckily I think we can worry about that later, just so long as we solve how we create word groups that can be identified, and also we need to make sure we have a good way of actually rigging these words to game logic. Briefly I thought I might be able to simply add this feature to our old tag decorated text logic. However, I'm worried the idea of tying game logic to words goes a bit too far beyond the scope of that library. Or maybe will just end up feeling like a hack job.

It's probably possible to add it in, but my gut says we should keep it separate. We should think next about how we'll actually construct a block of this interactable text. 

Actually, this may be more straightforward than I thought. Firstly, if create a collection of words or word groups, those could be organized by row just like our drawables, which quickly solves how controllers navigate them. And tying game logic to these just means including a callback function for each word/group. Now as for handling individual words vs groups, I think what makes more sense to think about first is how we'll build these. I think we should have a function which accepts an array of text entries. Each entry contains text, and an optional callback function. Something like this:

create_interactable_text([
    "The quick ",
    {
        text: "brown fox"
        callback: whatever
    },
    " jumps over the lazy ",
    {
        text: "dog",
        callback: whatever
    },
    "."
]);

For entries without a callback specified, we could just auto parse it into words that just don't have a callback. But the ones that do will get parsed into groups, as we demonstrated above. We could still create a listing of individual words anyway though, and just assign that same callback to all words from a group. We can easily decide one vs the other during playtesting.

But... looking over this now, I've realized something. That's going to be a huge pain to use for world creation. When I'm writing text, I want to be able to just write the text itself out, then apply callbacks later. Maybe we need to insist on connecting logic to words in a separate step:

create_interactable_text({
    text: "The quick brown fox jumps over the lazy dog",
    interacts: [
        {
            text: "quick brown fox",
            callback: whatever
        },
        {
            text: "lazy dog",
            callback: whatever
        }
    ]
});

Yeah, that's much better. Easier to write. What I think this means is we won't be able to create different logic for the same word in different context within the same text. Maybe that's ok?
